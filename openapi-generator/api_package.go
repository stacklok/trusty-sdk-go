/*
Trusty API

Trusty API

API version: v2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PackageAPIService PackageAPI service
type PackageAPIService service

type ApiV2GetAlternativesRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
}

func (r ApiV2GetAlternativesRequest) PackageName(packageName string) ApiV2GetAlternativesRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetAlternativesRequest) PackageType(packageType PackageType) ApiV2GetAlternativesRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetAlternativesRequest) PackageVersion(packageVersion string) ApiV2GetAlternativesRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetAlternativesRequest) Execute() (*PackageAlternatives, *http.Response, error) {
	return r.ApiService.V2GetAlternativesExecute(r)
}

/*
V2GetAlternatives Get Alternatives

This will return a list of alternative packages to the one requested.

It is based on AI and will try to provide something with similar functionality.

See [alternatives](alternatives.md) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetAlternativesRequest
*/
func (a *PackageAPIService) V2GetAlternatives(ctx context.Context) ApiV2GetAlternativesRequest {
	return ApiV2GetAlternativesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackageAlternatives
func (a *PackageAPIService) V2GetAlternativesExecute(r ApiV2GetAlternativesRequest) (*PackageAlternatives, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageAlternatives
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetAlternatives")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/alternatives"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetDependenciesRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
	filter *string
	sortBy *[]string
	sortOrder *[]string
	recurseLimit *int32
	pageFrom *int32
	pageTo *int32
}

func (r ApiV2GetDependenciesRequest) PackageName(packageName string) ApiV2GetDependenciesRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetDependenciesRequest) PackageType(packageType PackageType) ApiV2GetDependenciesRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetDependenciesRequest) PackageVersion(packageVersion string) ApiV2GetDependenciesRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetDependenciesRequest) Filter(filter string) ApiV2GetDependenciesRequest {
	r.filter = &filter
	return r
}

func (r ApiV2GetDependenciesRequest) SortBy(sortBy []string) ApiV2GetDependenciesRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiV2GetDependenciesRequest) SortOrder(sortOrder []string) ApiV2GetDependenciesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiV2GetDependenciesRequest) RecurseLimit(recurseLimit int32) ApiV2GetDependenciesRequest {
	r.recurseLimit = &recurseLimit
	return r
}

func (r ApiV2GetDependenciesRequest) PageFrom(pageFrom int32) ApiV2GetDependenciesRequest {
	r.pageFrom = &pageFrom
	return r
}

func (r ApiV2GetDependenciesRequest) PageTo(pageTo int32) ApiV2GetDependenciesRequest {
	r.pageTo = &pageTo
	return r
}

func (r ApiV2GetDependenciesRequest) Execute() (*DependencyResponse, *http.Response, error) {
	return r.ApiService.V2GetDependenciesExecute(r)
}

/*
V2GetDependencies Get Dependencies

Fetch the dependencies for a package given its name version and type.
This includes the package's name, version, description, and other metadata about contributors.

DependencyOptions:
filter (Optional[str]): CEL filter code to apply.
sort_by (Optional[List[str]]): List of fields to sort by.
sort_order (Optional[List[str]]): Corresponding list of sort orders.
recurse_limit (int): Maximum depth of recursion. Upper limit - should automatically stop at leaf nodes.
page_from (int): Pagination start.
page_to (int): Pagination end.

For details on how to use the filter look at the [CEL docs](https://cel.dev/overview/cel-overview)
Some examples:
- node.score == 0.0
- node.score > 0.0 && node.score < 5
- "Apache-2.0" in node.claims
See the [Trusty documentation](https://docs.stacklok.com/trusty/) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetDependenciesRequest
*/
func (a *PackageAPIService) V2GetDependencies(ctx context.Context) ApiV2GetDependenciesRequest {
	return ApiV2GetDependenciesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DependencyResponse
func (a *PackageAPIService) V2GetDependenciesExecute(r ApiV2GetDependenciesRequest) (*DependencyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependencyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetDependencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/dependencies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", t, "form", "multi")
		}
	}
	if r.recurseLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse_limit", r.recurseLimit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.recurseLimit = &defaultValue
	}
	if r.pageFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_from", r.pageFrom, "form", "")
	} else {
		var defaultValue int32 = 0
		r.pageFrom = &defaultValue
	}
	if r.pageTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_to", r.pageTo, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageTo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetDependenciesIdRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	id string
	filter *string
	sortBy *[]*string
	sortOrder *[]string
	recurseLimit *int32
	pageFrom *int32
	pageTo *int32
}

func (r ApiV2GetDependenciesIdRequest) Filter(filter string) ApiV2GetDependenciesIdRequest {
	r.filter = &filter
	return r
}

func (r ApiV2GetDependenciesIdRequest) SortBy(sortBy []*string) ApiV2GetDependenciesIdRequest {
	r.sortBy = &sortBy
	return r
}

func (r ApiV2GetDependenciesIdRequest) SortOrder(sortOrder []string) ApiV2GetDependenciesIdRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiV2GetDependenciesIdRequest) RecurseLimit(recurseLimit int32) ApiV2GetDependenciesIdRequest {
	r.recurseLimit = &recurseLimit
	return r
}

func (r ApiV2GetDependenciesIdRequest) PageFrom(pageFrom int32) ApiV2GetDependenciesIdRequest {
	r.pageFrom = &pageFrom
	return r
}

func (r ApiV2GetDependenciesIdRequest) PageTo(pageTo int32) ApiV2GetDependenciesIdRequest {
	r.pageTo = &pageTo
	return r
}

func (r ApiV2GetDependenciesIdRequest) Execute() (*DependencyResponse, *http.Response, error) {
	return r.ApiService.V2GetDependenciesIdExecute(r)
}

/*
V2GetDependenciesId Get Dependencies Id

Fetch the dependencies for a package given its id.
This includes the package's name, version, description, and other metadata about contributors.

DependencyOptions:
filter (Optional[str]): CEL filter code to apply.
sort_by (Optional[List[str]]): List of fields to sort by.
sort_order (Optional[List[str]]): Corresponding list of sort orders.
recurse_limit (int): Maximum depth of recursion. Upper limit - should automatically stop at leaf nodes.
page_from (int): Pagination start.
page_to (int): Pagination end.

For details on how to use the filter look at the [CEL docs](https://cel.dev/overview/cel-overview)
Some examples:
- node.score == 0.0
- node.score > 0.0 && node.score < 5
- "Apache-2.0" in node.claims

See the [Trusty documentation](https://docs.stacklok.com/trusty/) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiV2GetDependenciesIdRequest
*/
func (a *PackageAPIService) V2GetDependenciesId(ctx context.Context, id string) ApiV2GetDependenciesIdRequest {
	return ApiV2GetDependenciesIdRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DependencyResponse
func (a *PackageAPIService) V2GetDependenciesIdExecute(r ApiV2GetDependenciesIdRequest) (*DependencyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependencyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetDependenciesId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/dependencies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", t, "form", "multi")
		}
	}
	if r.recurseLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recurse_limit", r.recurseLimit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.recurseLimit = &defaultValue
	}
	if r.pageFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_from", r.pageFrom, "form", "")
	} else {
		var defaultValue int32 = 0
		r.pageFrom = &defaultValue
	}
	if r.pageTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_to", r.pageTo, "form", "")
	} else {
		var defaultValue int32 = 100
		r.pageTo = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetMaliciousRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
}

func (r ApiV2GetMaliciousRequest) PackageName(packageName string) ApiV2GetMaliciousRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetMaliciousRequest) PackageType(packageType PackageType) ApiV2GetMaliciousRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetMaliciousRequest) PackageVersion(packageVersion string) ApiV2GetMaliciousRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetMaliciousRequest) Execute() (bool, *http.Response, error) {
	return r.ApiService.V2GetMaliciousExecute(r)
}

/*
V2GetMalicious Get Malicious

This will return a flag reporting whether the package is known malicious.
This is currently manually curated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetMaliciousRequest
*/
func (a *PackageAPIService) V2GetMalicious(ctx context.Context) ApiV2GetMaliciousRequest {
	return ApiV2GetMaliciousRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return bool
func (a *PackageAPIService) V2GetMaliciousExecute(r ApiV2GetMaliciousRequest) (bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetMalicious")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/malicious"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetPackageRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	id string
}

func (r ApiV2GetPackageRequest) Execute() (*TrustyPackageResult, *http.Response, error) {
	return r.ApiService.V2GetPackageExecute(r)
}

/*
V2GetPackage Get Package

Fetch the info for a package given its id.
This includes the package's name, version, description, and other metadata about contributors.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiV2GetPackageRequest
*/
func (a *PackageAPIService) V2GetPackage(ctx context.Context, id string) ApiV2GetPackageRequest {
	return ApiV2GetPackageRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TrustyPackageResult
func (a *PackageAPIService) V2GetPackageExecute(r ApiV2GetPackageRequest) (*TrustyPackageResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrustyPackageResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/package/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetPackageProvenanceRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
	periodType *string
	periodCount *int32
}

func (r ApiV2GetPackageProvenanceRequest) PackageName(packageName string) ApiV2GetPackageProvenanceRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetPackageProvenanceRequest) PackageType(packageType PackageType) ApiV2GetPackageProvenanceRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetPackageProvenanceRequest) PackageVersion(packageVersion string) ApiV2GetPackageProvenanceRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetPackageProvenanceRequest) PeriodType(periodType string) ApiV2GetPackageProvenanceRequest {
	r.periodType = &periodType
	return r
}

func (r ApiV2GetPackageProvenanceRequest) PeriodCount(periodCount int32) ApiV2GetPackageProvenanceRequest {
	r.periodCount = &periodCount
	return r
}

func (r ApiV2GetPackageProvenanceRequest) Execute() (*ProvenanceResponse, *http.Response, error) {
	return r.ApiService.V2GetPackageProvenanceExecute(r)
}

/*
V2GetPackageProvenance Get Package Provenance

This will return the provenance of the package with respect to the package origins.
Can it be linked with a repo?

[Historical provenance](provenance.md#historical-provenance-hp)
This contains the number of `tags` in the repo, the number of `versions`
of the package, a count of the `common` tags and the ratio of tags to common
as `overlap`.
Also includes the historical information for tags, versions and matches for the given period type and count,
by default the last 12 months from the current date.

See [provenance](provenance.md) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetPackageProvenanceRequest
*/
func (a *PackageAPIService) V2GetPackageProvenance(ctx context.Context) ApiV2GetPackageProvenanceRequest {
	return ApiV2GetPackageProvenanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ProvenanceResponse
func (a *PackageAPIService) V2GetPackageProvenanceExecute(r ApiV2GetPackageProvenanceRequest) (*ProvenanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProvenanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetPackageProvenance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/provenance"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	if r.periodType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_type", r.periodType, "form", "")
	} else {
		var defaultValue string = "month"
		r.periodType = &defaultValue
	}
	if r.periodCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period_count", r.periodCount, "form", "")
	} else {
		var defaultValue int32 = 12
		r.periodCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetPkgRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
}

func (r ApiV2GetPkgRequest) PackageName(packageName string) ApiV2GetPkgRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetPkgRequest) PackageType(packageType PackageType) ApiV2GetPkgRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetPkgRequest) PackageVersion(packageVersion string) ApiV2GetPkgRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetPkgRequest) Execute() (*TrustyPackageData, *http.Response, error) {
	return r.ApiService.V2GetPkgExecute(r)
}

/*
V2GetPkg Get Pkg

Fetch the metadata for a package.

This includes the package's name, version, description, and other metadata about contributors.

See the [Trusty documentation](https://docs.stacklok.com/trusty/) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetPkgRequest
*/
func (a *PackageAPIService) V2GetPkg(ctx context.Context) ApiV2GetPkgRequest {
	return ApiV2GetPkgRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TrustyPackageData
func (a *PackageAPIService) V2GetPkgExecute(r ApiV2GetPkgRequest) (*TrustyPackageData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrustyPackageData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetPkg")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/pkg"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetSameOriginRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	token *string
}

func (r ApiV2GetSameOriginRequest) PackageName(packageName string) ApiV2GetSameOriginRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetSameOriginRequest) PackageType(packageType PackageType) ApiV2GetSameOriginRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetSameOriginRequest) Token(token string) ApiV2GetSameOriginRequest {
	r.token = &token
	return r
}

func (r ApiV2GetSameOriginRequest) Execute() (*SameOriginPackagesResult, *http.Response, error) {
	return r.ApiService.V2GetSameOriginExecute(r)
}

/*
V2GetSameOrigin Get Same Origin

This will return a list of packages sharing the same repo as the one requested.
This can be perfectly normal, many repos produce multiple artifacts,
or it can be a sign of star-jacking, depending on the provenance of the packages.

See [shared origin](shared_origin.md) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetSameOriginRequest
*/
func (a *PackageAPIService) V2GetSameOrigin(ctx context.Context) ApiV2GetSameOriginRequest {
	return ApiV2GetSameOriginRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SameOriginPackagesResult
func (a *PackageAPIService) V2GetSameOriginExecute(r ApiV2GetSameOriginRequest) (*SameOriginPackagesResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SameOriginPackagesResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetSameOrigin")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/same-origin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.token != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "token", r.token, "form", "")
	} else {
		var defaultValue string = ""
		r.token = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetSimilarRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
}

func (r ApiV2GetSimilarRequest) PackageName(packageName string) ApiV2GetSimilarRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetSimilarRequest) PackageType(packageType PackageType) ApiV2GetSimilarRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetSimilarRequest) PackageVersion(packageVersion string) ApiV2GetSimilarRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetSimilarRequest) Execute() (*PackageSimilarResult, *http.Response, error) {
	return r.ApiService.V2GetSimilarExecute(r)
}

/*
V2GetSimilar Get Similar

Similar packages are those that have similar names to others.

This may or may not be a sign of typosquatting, depending on the provenance of the packages.

See [similar packages](similar_packages.md) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetSimilarRequest
*/
func (a *PackageAPIService) V2GetSimilar(ctx context.Context) ApiV2GetSimilarRequest {
	return ApiV2GetSimilarRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackageSimilarResult
func (a *PackageAPIService) V2GetSimilarExecute(r ApiV2GetSimilarRequest) (*PackageSimilarResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageSimilarResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetSimilar")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/similar"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2GetSummaryRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	packageName *string
	packageType *PackageType
	packageVersion *string
}

func (r ApiV2GetSummaryRequest) PackageName(packageName string) ApiV2GetSummaryRequest {
	r.packageName = &packageName
	return r
}

func (r ApiV2GetSummaryRequest) PackageType(packageType PackageType) ApiV2GetSummaryRequest {
	r.packageType = &packageType
	return r
}

func (r ApiV2GetSummaryRequest) PackageVersion(packageVersion string) ApiV2GetSummaryRequest {
	r.packageVersion = &packageVersion
	return r
}

func (r ApiV2GetSummaryRequest) Execute() (*PackageSummaryAnnotation, *http.Response, error) {
	return r.ApiService.V2GetSummaryExecute(r)
}

/*
V2GetSummary Get Summary

Fetch the metadata for a package and compute the adjusted summary score.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2GetSummaryRequest
*/
func (a *PackageAPIService) V2GetSummary(ctx context.Context) ApiV2GetSummaryRequest {
	return ApiV2GetSummaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PackageSummaryAnnotation
func (a *PackageAPIService) V2GetSummaryExecute(r ApiV2GetSummaryRequest) (*PackageSummaryAnnotation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PackageSummaryAnnotation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2GetSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.packageName == nil {
		return localVarReturnValue, nil, reportError("packageName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "package_name", r.packageName, "form", "")
	if r.packageType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_type", r.packageType, "form", "")
	}
	if r.packageVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "package_version", r.packageVersion, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2PostPackageRequest struct {
	ctx context.Context
	ApiService *PackageAPIService
	requestBody *[]string
}

func (r ApiV2PostPackageRequest) RequestBody(requestBody []string) ApiV2PostPackageRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiV2PostPackageRequest) Execute() ([]TrustyPackageResult, *http.Response, error) {
	return r.ApiService.V2PostPackageExecute(r)
}

/*
V2PostPackage Post Package

Fetch the info for a package given its id.
This includes the package's name, version, description, and other metadata about contributors.
See the [Trusty documentation](https://docs.stacklok.com/trusty/) for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiV2PostPackageRequest
*/
func (a *PackageAPIService) V2PostPackage(ctx context.Context) ApiV2PostPackageRequest {
	return ApiV2PostPackageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TrustyPackageResult
func (a *PackageAPIService) V2PostPackageExecute(r ApiV2PostPackageRequest) ([]TrustyPackageResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TrustyPackageResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PackageAPIService.V2PostPackage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/package"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
